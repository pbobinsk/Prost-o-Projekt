name: System E2E Tests (Dockerized)

on:
  workflow_dispatch:
  push:
    branches: [ "main", "phase-*" ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'

jobs:
  e2e-tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 1. Tworzymy .env (nadal potrzebny dla aplikacji)
      - name: Create .env file
        run: |
          echo "JWT_SECRET=ci-secret-key-123" > .env
          # WAŻNE: Wewnątrz sieci Dockera frontend to 'http://frontend', a nie localhost!
          echo "BASE_URL=http://frontend" >> .env 

      # 2. Uruchamiamy system (Aplikację)
      # Używamy flagi '-p', aby nazwa sieci była stała: 'prost-o-projekt_default'
      - name: Start System
        run: docker compose -p prost-o-projekt up -d --build

      # 3. Czekamy na gotowość (Twój skrypt healthcheck)
      - name: Wait for Services
        timeout-minutes: 5
        run: |
          # Tutaj sprawdzamy localhost, bo curl działa z poziomu runnera (zewnątrz kontenerów)
          # Porty 3000 i 80 są zmapowane na hosta, więc to zadziała.
          echo "Czekam na API Gateway..."
          until curl -s -f -o /dev/null "http://localhost:3000"; do
            sleep 5
          done
          echo "✅ API Gateway działa!"

          echo "Czekam na Frontend..."
          until curl -s -f -o /dev/null "http://localhost:80"; do
            sleep 5
          done
          echo "✅ Frontend działa!"

      # 4. Uruchamiamy testy E2E (W DOCKERZE)
      # To jest kluczowa zmiana!
      # Używamy tego samego 'docker-compose.test.yml' co lokalnie.
      # Podpinamy się pod ten sam projekt (-p prost-o-projekt), żeby widzieć sieć.
      - name: Run Playwright Tests (Docker)
        run: |
          docker compose -p prost-o-projekt -f docker-compose-test.yml run --rm e2e-tests

      # 5. Logi w razie błędu
      - name: Dump Docker Logs
        if: failure()
        run: docker compose -p prost-o-projekt logs